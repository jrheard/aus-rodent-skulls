### 21 May 2018: Created to analyze Australian rodent morphology study with data from Viewbox

##############################################################
"########################  Data Set up  ######################"
##############################################################

## Do once:
library(devtools)
install_github("TGuillerme/landmark-test")

## Load necessary libraries
library(dplyr)
library(stringr)
library(stringi)
library(data.table)
library(geomorph)
library(MASS)
library(ggplot2)
library(landmarktest) # work in progress package by Thomas Guillerme, downloaded from github

setwd("~/Documents/Ariel's Folder/Research/3 Australian Rodent Evo/Chp3_Crania_Morph/data/3_coordinate_data")

## Read in data file and get it into format that geomorph recognizes
my_data <- read.csv("18_07_20_7Roundsminus20.csv", header = T) # choose Raw_Coordinates.csv
# removed Not_mit_J3351
# removed Leg_for_JM14820
# removed Leg_for_JM10913

data <- my_data[, 2:(dim(my_data)[2])] # get rid of LM names for geomorph
data <- t(data)
A <- arrayspecs(data, 405, 3) # convert to 3D array w 405 pts & 3 dims

# Create LM point name metadata
pt_names <-my_data[, 1]
foo2 <- str_sub(pt_names, 3, -1)
u_pt_names<- unique(foo2)

## Create function to scrape filenames for metadata
Metadata <- function(threeDarray, cols) {
        names <- dimnames(threeDarray)[[3]]
        names <- gsub("ind", "", names)
        names <- gsub("_f_", "_", names)
        names <- gsub("_m_", "_", names)
        names <- gsub("_ERR", "", names)
        categories <- strsplit(names, "_") 
        my_classifiers <- matrix(unlist(categories), ncol = length(cols), byrow = T) 
        colnames(my_classifiers) <- cols
        sp_info <- as.data.frame(my_classifiers)
        sp_info$Taxa <- paste(str_sub(sp_info$Genus, 1, 1), str_sub(sp_info$Species, 1, 3), sep = "_")
        sp_info$All <- with(sp_info, interaction(Genus, Species, CatNum, sep = "_"))
        return(sp_info)
}

# Create metadata table
cols = c("Genus", "Species","CatNum","Patch")
sp_info <- Metadata(A, cols)

## Split datasets into small and big patch types
big_data <- sp_info$Patch == "big"
big_pts <- which(!str_detect(u_pt_names, "PAT2") & !str_detect(u_pt_names, "SUR2")) # gets rid of columns meant for small patch dataset
B <- A[big_pts, , big_data]
big_sp_info <- sp_info[big_data, ]
big_sp_info$Order <- c(1:nrow(big_sp_info))
big_pt_names <- u_pt_names[big_pts]

sm_data <- sp_info$Patch == "small"
sm_pts <- which(!str_detect(u_pt_names, "PAT D")) # gets rid of columns meant for small patch dataset
S <- A[sm_pts, , sm_data]
sm_sp_info <- sp_info[sm_data, ]
sm_sp_info$Order <- c(1:nrow(sm_sp_info))
sm_pt_names <- u_pt_names[sm_pts]

## Create vectors of patch points and semi-landmarks
# Patch points
big_patches <- str_detect(big_pt_names, "PAT")
big_pat_num <- which(big_patches == TRUE)

sm_patches <- str_detect(sm_pt_names, "PAT")
sm_pat_num <- which(sm_patches == TRUE)

# Semi-landmark curves
big_cur <- str_detect(big_pt_names, "SUR")
big_cur_num <- which(big_cur == TRUE)

sm_cur <- str_detect(sm_pt_names, "SUR")
sm_cur_num <- which(sm_cur == TRUE)

## Use the above to help make curve sliding matrix required by geomorph
# These steps only need to be done once, then the final product is saved as "slider_matrix" and loaded with read.csv

## Function
Dummy_Slider <- function(cur_num){
        Before <- (cur_num - 1)
        Slider <- cur_num
        After <- (cur_num + 1)
        matrix <- cbind(Before, Slider, After)
        return(matrix)
}

big_cur_matrix <- Dummy_Slider(big_cur_num)
sm_cur_matrix <- Dummy_Slider(sm_cur_num)

# Create table to specify LM names that bound curves
curve_names <- unique(str_sub(sm_pt_names, 1, -5))
curve_names <- curve_names[str_detect(curve_names, "SUR")]
write.csv(curve_names, "curve_names.csv")
## manually input which LMs go before the max # curve point and after curve point #1
LM_key <- read.csv("curve_LM_key.csv", header = T)

### A function that replaces before and after column numbers with the correct landmark numbers
## requires a list of point names extracted from the coordinate data
## reguires a user-created key with columns:
# "Curve": unique curves (L and R sides should not be duplicated)
# "Before": the landmark that comes before the highest point in the curve, again no R or L side should be indicated
# "After": the landmark that comes after the lowest point in the curve
## A matrix generated by function Dummy_Slider() above
Write_Slider <- function(pt_names, key, matrix){
        
        Give_LMs <- function(i, index, pt_names, key, matrix){
                
                bef_LM <- as.character(LM_key$Before[i])
                if ((sum(str_detect(pt_names, bef_LM)) > 1)) {
                        side <- str_sub(pt_names[min(index)], -3, -3)
                        bef_LM <- paste(bef_LM, side, sep = " ")
                } 
                LM_num <- which(str_detect(pt_names, bef_LM))
                matrix[min(index), 1] <- LM_num
                
                aft_LM <- as.character(key$After[i])
                if (sum(str_detect(pt_names, aft_LM)) > 1) {
                        side <- str_sub(pt_names[min(index)], -3, -3)
                        aft_LM <- paste(aft_LM, side, sep = " ")
                } 
                LM_num <- which(str_detect(pt_names, aft_LM))
                matrix[max(index), 3] <- LM_num
                
                return(matrix)
        }
        
        for (i in 1:length(key$Curve)){
                curve <- as.character(key$Curve[i])
                
                if (sum(str_detect(pt_names, curve) != 0)){
                        index <- which(str_detect(pt_names, curve))
                        test_letter <- str_sub(pt_names[min(index)], -3, -3)
                        if (test_letter != "R" & test_letter != "L"){
                                matrix <- Give_LMs(i, index, pt_names, key, matrix)
                        } else {
                                midpt <- length(index)/2
                                R_index <- index[1:midpt]
                                L_index <- index[(midpt + 1):length(index)]
                                matrix <- Give_LMs(i, R_index, pt_names, key, matrix)
                                matrix <- Give_LMs(i, L_index, pt_names, key, matrix)
                        }
                }

                }
        
        return(matrix)
}

# Create slider matrices for each dataset
big_sli_matrix <- Write_Slider(big_pt_names, LM_key, big_cur_matrix)
sm_sli_matrix <- Write_Slider(sm_pt_names, LM_key, sm_cur_matrix)


### Write a function to create matrix of bilateral points
Find_Pairs <- function(pt_names){
        no_side_names <- gsub(" R", "", pt_names)
        no_side_names <- gsub(" L", "", no_side_names)
        pairs <- data.table("Right" = numeric(), "Left" = numeric())
        
        for(i in unique(no_side_names)){
                index <- str_detect(no_side_names, i)
                if (sum(index) == 2) {
                        new_pair <- which(index == TRUE)
                        pairs <- rbind(pairs, as.list(new_pair))
                } 
        }
        return(pairs)
}

big_land_pairs <- Find_Pairs(big_pt_names)
sm_land_pairs <- Find_Pairs(sm_pt_names)


##############################################################
"########################  Analyses  #########################"
##############################################################

### Datasets with asymmetry
## Perform procrustes alignment in R with geomorph for all data
big_Y <- gpagen(B, Proj = TRUE, ProcD = TRUE, curves = big_sli_matrix, surfaces = big_pat_num)

sm_Y <- gpagen(S, Proj = TRUE, ProcD = TRUE, curves = sm_sli_matrix, surfaces = sm_pat_num)


#sm_Y <- gpagen(S, Proj = TRUE, ProcD = TRUE)

#bi_big_Y <- bilat.symmetry(big_Y$coords, ind = big_sp_info$All, object.sym = T, replicate = NULL, side = NULL, land.pairs = big_land_pairs)
#big_bY <- bi_big_Y$symm.shape # Analogous to Y$coords
# Create new table of specimen information since the bilat function rearranges the coordinate array
#cols2 = c("Genus", "Species", "CatNum")
#big_bY_info <- Metadata(big_bY, cols2)

#bi_sm_Y <- bilat.symmetry(sm_Y$coords, ind = sm_sp_info$All, object.sym = T, replicate = NULL, side = NULL, land.pairs = sm_land_pairs)
#sm_bY <- bi_sm_Y$symm.shape
#sm_bY_info <- Metadata(sm_bY, cols2)

"### 1) Exploratory PCA ###"
"##########################"
### Figures TK ###

## Graph the PCA for the big patch dataset
# Assign colors
big_gp <- as.factor(big_sp_info$Genus)
big_col.gp <- c("red", "cornflowerblue", "light green", "dark blue", "yellow", "green", "grey", "blue", "magenta", "dark blue", "black", "darkgoldenrod4", "orange", "light blue")
# Hyd Leg Lep Mas 
# Mel Mes Mus Not Pog Pse Rat 
# Uro Xer Zyz
names(big_col.gp) <- levels(big_gp)
big_col.gp <- big_col.gp[match(big_gp, names(big_col.gp))] # colors by genus

## Plot PCAs
big_pca <- plotTangentSpace(big_Y$coords, groups = big_col.gp, axis1 = 1, axis2 = 2, label = big_sp_info$CatNum, verbose = T) # change axis1 to see warpplots for different PCs

# Pretty Plot
plot(-big_pca$pc.scores[,1], big_pca$pc.scores[,2], asp = T, xlab = "PC1 (41.9%)", ylab = "PC2 (9.89%)", col = big_col.gp, pch = 16, cex = 1.5, bg = big_col.gp, cex.axis = 1.3, cex.lab = 1.3)
axis(side = 1, at = c(-0.2,0.1), labels = FALSE, col.ticks = "white")


# Check for outliers
outliers <- plotOutliers(big_Y$coords)

# Look at outliers
is <- which(big_sp_info$CatNum == "J21273")
isTaxa <- which(big_sp_info$Taxa == "H_chr")
plotRefToTarget(big_Y$coords[,,5], big_Y$coords[,,64], method = "vector", label = F)
b_names[5,]


## Graph the PCA for the small patch dataset
# Assign colors
sm_gp <- as.factor(sm_sp_info$Genus)
sm_col.gp <- c("red", "cornflowerblue", "light green", "dark blue", "yellow", "green", "grey", "blue", "magenta", "dark blue", "black", "darkgoldenrod4", "orange", "light blue")
# Hyd Leg Lep Mas Mel Mes Mus Not Pog Pse Rat Uro Xer Zyz
names(sm_col.gp) <- levels(sm_gp)
sm_col.gp <- sm_col.gp[match(sm_gp, names(sm_col.gp))] # colors by Genus

## Plot PCAs
sm_pca <- plotTangentSpace(sm_Y$coords, groups = sm_col.gp, axis1 = 2, axis2 = 3, warpgrids = T, verbose = T) # change axis1 to see warpplots for different PCs

# Pretty Plot
plot(-sm_pca$pc.scores[,1], sm_pca$pc.scores[,2], asp = T, xlab = "PC1 (41.4%)", ylab = "PC2 (10.3%)", col = sm_col.gp, pch = 16, cex = 1.5, bg = sm_col.gp, cex.axis = 1.3, cex.lab = 1.3)
axis(side = 1, at = c(-0.2,0.1), labels = FALSE)


"### 2) Shape Change Heatmap ###"
"###############################"
# species_dataset = gpa data
# axis is for the first PC axis

pr_PCA <- prcomp(two.d.array(sm_Y$coords))

variation <- variation.range(sm_Y, return.ID = TRUE, axis = 1, ordination = pr_PCA)

plotRefToTarget.heat(sm_Y$coords[,, variation$min.max[1]],
                     sm_Y$coords[,, variation$min.max[2]],
                     col = heat.colors, pt.size = 0.7, col.val = variation$range[,1],
                     plotRefToTarget.args = list(mag = 1))


"### 3) GPA by Attributes ###"
"############################"

## Combine trait metadata with sp info 
setwd("~/Documents/Ariel's Folder/Research/3 Australian Rodent Evo/Chp3_Crania_Morph/data/4_trait_info")
traits <- read.csv("in_ex_traits.csv", header = TRUE)
traits$Taxa <- paste(str_sub(traits$Genus, 1, 1), str_sub(traits$Species, 1, 3), sep = "_")

trait_sp_info <- merge(sm_sp_info[-4], traits[3:8], by = "Taxa")
trait_sp_info <- trait_sp_info[order(trait_sp_info$Order),]

## PCA by Feeding x Guild
# Assign colors by feeding
feed_gp <- as.factor(trait_sp_info$Feeding)
feed_col.gp <- c("red", "darkorange", "gold", "green", "burlywood4")
# Key: Carnivorous, Frugivorous, Granivorous, Herbivorus, Omnivorous
names(feed_col.gp) <- levels(feed_gp)
feed_col.gp <- feed_col.gp[match(feed_gp, names(feed_col.gp))] 

# Assign plot point by guild
gld.gp <- as.factor(trait_sp_info$Guild)
gld_pch.gp <- c(19, 24, 22)
# Key: Aquatic (circle), Arboreal (triangle), Terrestrial (square)
names(gld_pch.gp) <- levels(gld.gp)
gld_pch.gp <- gld_pch.gp[match(gld.gp, names(gld_pch.gp))]

# Plot PCA
fg_pca <- plotTangentSpace(sm_Y$coords, groups = feed_col.gp, axis1 = 1, axis2 = 2, verbose = T) # change axis1 to see warpplots for different PCs

plot(-fg_pca$pc.scores[,1], fg_pca$pc.scores[,2], asp = T, xlab = "PC1 (41.4%)", ylab = "PC2 (10.3%)", col = feed_col.gp, pch = gld_pch.gp, cex = 1.5, bg = feed_col.gp, cex.axis = 1.3, cex.lab = 1.3)
axis(side = 1, at = c(-0.2,0.1), labels = FALSE)
legend(-0.1005, 0.083, legend = c("Aquatic", "Arboreal", "Terrestrial"), col = "black", pch = c(21, 24, 22))
text(0.05, 0.045, "Carnivore", col = "red")
text(0.085, -0.042, "Frugivore", col = "darkorange")
text(0.03, -0.045, "Herbivore", col = "green")
text(-0.04, -0.035, "Omnivore", col = "burlywood4")
text(-0.079, 0.017, "Granivore", col = "gold2")
#text(pca$pc.scores[,1], pca$pc.scores[,2], labels = b_names$CatNum, cex = 0.7)


"### 4) Allometry Analysis ###"
"#############################"
# Set color scheme
sm_color <- c("yellow", "darkgoldenrod4", "green", "light green", "cornflowerblue", "light blue", "blue", "dark blue", "red", "orange", "magenta", "grey", "black")
genus_name <- c("Mel", "Uro", "Mes", "Lep", "Leg", "Zyz", "Not", "Pse", "Hyd", "Xer", "Pog", "Mus", "Rat")

# Find Pearson's r
cor.test(sm_Y$Csize, -sm_pca$pc.scores[,1], method = "pearson")
# cor = 0.89
# p-value < 0.001

## Assess correlation of PC1 to Centroid size
plot(sm_Y$Csize, -sm_pca$pc.scores[,1], xlim = c(120, 455), col = sm_col.gp, pch = 16, xlab = "Centroid size", ylab = "PC1 score", main = "PC1 vs Size")
legend(410, 0.115, legend = genus_name, col = sm_color, pch = 16)
text(300, 0, "r = 0.89", col = "dark grey")

## Graph Predicted allometric shape slope
gdf <- geomorph.data.frame(coords = sm_Y$coords, csize = sm_Y$Csize, genus = sm_sp_info$Genus)

Allo <- procD.allometry(coords ~ csize, ~ genus, logsz = TRUE, iter = 999, RRPP = TRUE, data = gdf)
summary(Allo)

# Plot results
plot(log(Allo$size), -(Allo$pred.val), xlim = c(4.75, 6.25), col = sm_col.gp, pch = 16, xlab = "Log centroid size", ylab = "Predicted shape", main = "Predicted Allometric Shape by Genus")
legend(6.04, 0.11, legend = genus_name, col = sm_color, pch = 16)

#plot(Allo, method = "PredLine", col = sm_col.gp, pch = 16)
#plot(Allo, method = "CAC", col = sm_col.gp, pch = 16)
#plot(Allo, method = "RegScore")

## Post-hoc test
postHoc <- advanced.procD.lm(coords ~csize * genus, ~csize + genus, groups = ~genus, slope = ~csize, angle.type = "deg", iter = 999, data = gdf)

posthoc2 <- procD.allometry(coords ~csize * genus, angle.type = "deg", iter = 999, data = gdf)

postHoc

write.csv(postHoc$P.angles, na = "-", file = "18_07_20_Genus_PostHoc.csv")


gdf <- geomorph.data.frame(coords = Pse_Y$coords, csize = Pse_Y$Csize, genus = Pse_sp_info2$Taxa)
postHoc <- advanced.procD.lm(coords ~csize * genus, ~csize + genus, groups = ~genus, slope = ~csize, angle.type = "deg", iter = 999, data = gdf)
postHoc


"### 5) GPA by Groups ###"
"########################"
## Assume that I'm working only with small-patch data from here;
## Currently also assumes that non-bilateral data is being used

## Write function to section metadata by group assuming you refer to the new Taxa column described above; returns logical list of data to keep
SectionData <- function(metacolumn, kindtokeep) {
        is_keep <- logical(length(metacolumn))
        for (kind in kindtokeep) {
                is_kind <- metacolumn == kind
                is_keep <- is_kind | is_keep
        }
        return(is_keep)
}

## Input colors for taxa of interest
sm_gp <- as.factor(sm_sp_info$Genus)
colkey <- c("red", "cornflowerblue", "light green", "dark blue", "yellow", "green", "grey", "blue", "magenta", "dark blue", "black", "darkgoldenrod4", "orange", "light blue")
# Hyd Leg Lep Mas Mel Mes Mus Not Pog Pse Rat Uro Xer Zyz

## Write function to match up colors & do allometry
MatchColors <- function(metadata, colkey){
        sm_gp <- as.factor(metadata$Taxa)
        names(colkey) <- levels(sm_gp)
        col.gp <- colkey[match(sm_gp, names(colkey))]
        return(col.gp)
}

## Function to perform allometry in closed environment
DoAllometry <- function(data3D, metadata, col.gp){
        gdf <- geomorph.data.frame(coords = data3D$coords, csize = data3D$Csize, taxa = metadata$Taxa)
        
        Allo <- procD.allometry(coords ~ csize, ~taxa, logsz = TRUE, iter = 999, RRPP = TRUE, data = gdf)
        return(Allo)
}

## Post-hoc test function in closed environment
PostHoc <- function(data3D, metadata) {
        gdf <- geomorph.data.frame(coords = data3D$coords, csize = data3D$Csize, taxa = metadata$Taxa)
        
        postHoc <- advanced.procD.lm(Pse_coords ~csize * taxa, ~csize + taxa, groups = ~taxa, slope = ~csize, angle.type = "deg", iter = 999, data = gdf)
        return(postHoc)
}


##### Test run #######

### Pseudomys group
taxatokeep <- c("M_fus", "P_aus", "P_del", "P_des", "P_gra", "P_her", "P_hig", "P_nov", "P_ora", "P_pat", "P_sho")
is_keep <- SectionData(sm_sp_info$Taxa, taxatokeep)

# Section 3D coord data and metadata with output from above
Pse_S<- S[,,is_keep]
Pse_sp_info <- sm_sp_info[is_keep,]

# Do file gymnastics to get around error thrown by advanced.procD()
write.csv(Pse_sp_info, "Test_Pse_info")
Pse_sp_info <- read.csv("Test_Pse_info", header = TRUE)

# GPA
Pse_Y <- gpagen(Pse_S, Proj = TRUE, ProcD = TRUE, curves = sm_sli_matrix, surfaces = sm_pat_num)

## Plot PCA
Pse_colkey <- c("green", "yellow", "pink", "brown", "green", "pink", "yellow", "pink", "blue", "grey", "brown")
#M_fus P_aus P_del P_des P_gra P_her P_hig P_nov P_ora P_pat P_sho
# green = broad, yellow = false, pink = delicate, brown = grizzled, blue = misc, grey = pebble
Pse_col.gp <- MatchColors(Pse_sp_info, Pse_colkey)

Pse_pca <- plotTangentSpace(Pse_Y$coords, groups = Pse_col.gp, axis1 = 1, axis2 = 2, label = Pse_sp_info$Taxa, verbose = T)

## Do Allometry
Allo <- DoAllometry(Pse_Y, Pse_sp_info, Pse_col.gp)
summary(Allo)

# Do plots & Post-hoc test
plot(log(Allo$size), (Allo$pred.val), col = Pse_col.gp, pch = 16, label = Pse_sp_info$Taxa)
Pse_posthoc <- PostHoc(Pse_Y, Pse_sp_info)

# Save results
write.csv(postHoc$P.angles, na = "-", file = "18_06_22_Pse_PostHoc.csv")




## Examine Rattus morphospace
is_keep <- SectionData(sm_sp_info$Genus, "Rat")

# Section 3D coord data and metadata with output from above
rat_S<- S[,,is_keep]
rat_sp_info <- sm_sp_info[is_keep,]
rat_pc1 <- sm_pca$pc.scores[is_keep, 1]
rat_pc2 <- sm_pca$pc.scores[is_keep, 2]
rat_size <- sm_Y$Csize[is_keep]

# Define colors
rat_colkey <- c("skyblue4", "indianred4", "seagreen3", "tan4", "black", "greenyellow", "seagreen1", "yellow")
# R_fus, R_leu, R_lut, R_nor, R_rat, R_sor, R_tun, R_vil
rat_col.gp <- MatchColors(rat_sp_info, rat_colkey)

# Plot PCA
plot(-rat_pc1, rat_pc2, col = rat_col.gp, xlim = c(-0.02, 0.07), pch = 16, xlab = "PC1", ylab = "PC2", main = "PC1 vs PC2, Rattus only")

# Legend in order of phylogeny
rat_taxa <- c("R_leu", "R_fus", "R_lut", "R_tun", "R_sor", "R_vil", "R_rat", "R_nor")
rat_color <- c("indianred4", "skyblue4", "seagreen3", "seagreen1", "greenyellow", "yellow", "black", "tan4")

legend(0.054, 0.037, legend = rat_taxa, col = rat_color, pch = 16)


## Rattus allometry
# Find Pearson's r
cor.test(rat_size, -rat_pc1, method = "pearson")
# cor = 0.87
# p-value < 0.001

plot(rat_size, -rat_pc1, col = rat_col.gp, xlim = c(200, 280), pch = 16, xlab = "Centroid size", ylab = "PC1 score", main = "PC1 vs Size, Rattus only")
legend(266, 0.055, legend = rat_taxa, col = rat_color, pch = 16)
text(240, 0, "r = 0.87", col = "dark grey")

# look at heatmap of extremes




## Don't need the following:

variation <- variation.range(sm_Y, return.ID = TRUE)

plotRefToTarget.heat(sm_Y$coords[,,variation$min.max[1]],
                     sm_Y$coords[,,variation$min.max[2]],
                     col = heat.colors, pt.size = 0.7, col.val = variation$range[,1],
                     plotRefToTarget.args = list(mag = 1))




plotRefToTarget(sm_pca$pc.shapes[[variation$min.max[1]]],
                     sm_pca$pc.shapes[[variation$min.max[2]]],
                     pt.size = 0.7, mag =10, method = "vector")

heatplot.PCs <- function(species_dataset, minfirst, PC_axis,...){
        
        ## Procrustes variation ranges for PCA; axis determines which ordination axis to use
        variation <- variation.range(species_dataset$procrustes, return.ID = TRUE, axis=PC_axis, ordination=species_dataset$ordination)
        
        # identifies specimens at opposite ends of the PC spectrum
        specimens_min_max <- variation$min.max
        
        #determines range of variation between PC extremes
        procrustes_var <- variation$range[,1]
        
        #runs PCA for min/max plotting
        PCA=plotTangentSpace(species_dataset$procrustes$coords, verbose=FALSE)
        
        gridPar = gridPar(pt.bg = "white", pt.size = 0.5)
        
        #converting pc shape ID of PCA into column numbers so the PC number can be chosen (e.g. PC6min is PCA$pc.shapes[[11]])
        
        pc_IDs <- c(PC_axis*2-1, PC_axis*2)
        
        if(minfirst==TRUE){
                open3d()
                plotRefToTarget.heat(PCA$pc.shapes[[pc_IDs[1]]],
                                     PCA$pc.shapes[[pc_IDs[2]]],
                                     col = heat.colors, pt.size = 0.7, col.val = procrustes_var,
                                     plotRefToTarget.args = list(mag = 1),...)}
        else {
                open3d()
                plotRefToTarget.heat(PCA$pc.shapes[[pc_IDs[2]]],
                                     PCA$pc.shapes[[pc_IDs[1]]],
                                     col = heat.colors, pt.size = 0.7, col.val = procrustes_var,
                                     plotRefToTarget.args = list(mag = 1), ...)}
}