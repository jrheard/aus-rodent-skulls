---
title: "03-find-bilateral-symmetry"
author: "Ariel Marcy"
date: "9/25/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '../aus-rodent-skulls')
```

# Extract symmetric component of shape data
We found in Marcy et al. 2018, that using bilateral shape data improved the reliability of landmarking for small 3D-scanned skulls. Here we prepare the data for bilateral symmetry, run _geomorph_'s `bilat.symmetry()` function, and summarize the results of the bilateral symmetry Procrustes ANOVA.

### Load packages
```{r message = FALSE}
library(stringr)
library(stringi)
library(data.table)
library(geomorph)
```

### Load data from previous steps
```{r}
load(file = "../Data/Results/01-big-patch-data.rda")
load(file = "../Data/Results/01-sm-patch-data.rda")
load(file = "../Data/Results/02-GPA-data.rda")
```

## Prepare data for running `bilat.symmetry()` function
To use _geomorph_'s `bilat.symmetry()` function, we needed to write a function to find the bilateral landmark pairs. Like in script 02, we assumed the user included R and L for side and numbered the curve and patch points in a mirror-image pattern relative to one another.
```{r}
FindPairs <- function(pt.names){
        # Creates table of paired bilateral landmarks for bilat.symmetry().
        #
        # Args:
        #   pt.names: a character vector of landmark names.
        #
        # Returns:
        #   2 column data table of paired landmarks ready for geomorph's bilat.symmetry()'s land.pair argument.
        
        pairs <- data.table("Right" = numeric(), "Left" = numeric())
        
        # Removes R and L designations so pairs can be detected
        no.side.names <- gsub(" R", "", pt.names)
        no.side.names <- gsub(" L", "", no.side.names)
        
        # Checks if point has a pair and if so, their index #s are paired
        for(i in unique(no.side.names)){
                index <- str_detect(no.side.names, i)
                if (sum(index) == 2) {
                        new.pair <- which(index == TRUE)
                        pairs <- rbind(pairs, as.list(new.pair))
                } 
        }
        return(pairs)
}

# Find landmark pair tables for each protocol
big.land.pairs <- FindPairs(big.pt.names)
sm.land.pairs <- FindPairs(sm.pt.names)
```

### Run bilateral GPA
Now we are ready to re-run the generalized Procrustes alignment using bilateral landmark designations, extract the symmetric component of shape, and make new metadata tables.

The two bilateral GPAs can take some time (~10min total to run).
```{r}
# Perform bilateral procrustes alignment on each patch protocol
big.biY <- bilat.symmetry(big.Y$coords, ind = big.sp.info$All, object.sym = T, replicate = NULL, side = NULL, land.pairs = big.land.pairs)

# Extract symmetric component of shape data
big.bY.ss <- big.biY$symm.shape  # analogous to Y$coords, where Y is the output of gpagen()

# Create new table of specimen information since the bilat function rearranges the coordinate array
cols2 <- c("Genus", "Species", "CatNum", "Rep")  # column names minus Patch
big.bY.info <- WriteMetadata(big.bY.ss, cols2)

# Repeat steps above for small patch protocol
sm.biY <- bilat.symmetry(sm.Y$coords, ind = sm.sp.info$All, object.sym = T, replicate = NULL, side = NULL, land.pairs = sm.land.pairs)
sm.bY.ss <- sm.biY$symm.shape
sm.bY.info <- WriteMetadata(sm.bY.ss, cols2)
```

## Summarize results from bilateral symmetry analyses
These results may be relevant for researchers interested in how much variation can be explained by symmetric variation among specimens, asymmetric variation among specimens, and fluctating asymmetry within specimens. 
```{r}
# Big patch protocol
summary(big.biY)
# Small patch protocol
summary(sm.biY)
```
Interestingly, we observe that the big patch protocol has elevated asymmetry relative to the small patch protocol (side Rsq = .11 vs .04). We suspect this is because it was impossible to get a perfectly mirror-image-matched large patch on the dorsal surface of the skull in Viewbox. Perhaps this asymmetry, hard-coded into the patch protocol, contributed to an increase in asymmetry measured compared to the small patch protocol. The small patch protocol had fewer patch points and it was easier to make mirror-image small patches.

### Save intermediate data
```{r}
save(big.biY, big.bY.ss, big.bY.info, file = "../Data/Results/03-big-bilat-data.rda")
save(sm.biY, sm.bY.ss, sm.bY.info, file = "../Data/Results/03-sm-bilat-data.rda")
```