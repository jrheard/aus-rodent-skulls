---
title: "01-extract-data-for-analyses"
author: "Ariel Marcy"
date: "9/17/2018"
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '../aus-rodent-skulls')
```

# Converting information from Viewbox into shape and metadata
This code extracts two kinds of data from an excel sheet of coordinates exported from Viewbox, a 3D landmarking software (dHAL software, Kifissia, Greece; www.dhal.com; Polychronis et al. 2013). The first is the shape information from the 3D coordinates. The second is the metadata stored in the filename for each specimen. These datasets need to be treated differently in the upcoming analyses while also remaining comparable by maintaining the same order of specimens.

Almost all upcoming analyses are done in the geometric morphometric R package, _geomorph_(Adams 2016; Adams & Otarola-Castillo 2013).

### Load packages
```{r message = FALSE}
library(dplyr)
library(stringr)
library(stringi)
library(data.table)
library(geomorph)
```

## Prepare shape data for analyses in _geomorph_
_Note that the data is loaded in using a relative directory - not a `setwd()` command. This allows others who have cloned this repo of code and data to still use the code out of the box._

Viewbox exports the data as a 2D array with specimens as columns and X, Y, and Z coordinates as rows for landmark. For _geomorph_, we need to convert this into a 3D array where each specimen has its own 2D array of 3 columns for XYZ coordinates and a row for each landmark. In other words, a 3D array has dimensions (p x k x n), where p is the number of landmarks, k is the dimension (2 or 3), and n is the number of specimens.

We also need to extract the metadata contained in the specimen filenames (exported as column names) and preserve their order so that the metadata matches the order of specimens in the shape data.

### Remove "burn-in" specimens from dataset to reduce user error
First, to reduce user error, AEM landmarked 20 specimens to familiarize herself with the template and re-landmarked those 20 later on. This is the standard "burn-in" number recommended by GMM veterans like _geomorph_ co-author, Dr Emma Sherratt (see her guides [here](http://www.emmasherratt.com/morphometrics/)).

Viewbox puts the most recent specimen in the first row of the output .csv file, which is why we take the 20 initial specimens from the last rows of the coordinate dataset. 
```{r}
coords.3D <- read.csv("../Data/Raw/3D_coords.csv", header = T)
coords.3D <- coords.3D[1:(length(coords.3D) - 40)]  # removes 1st 20 landmarked, with 2 protocols per specimen = 40
```

### Convert to 3D array
Here, we convert the coordinates into a 3D array for _geomorph_. Importantly, we need to remove the 1st column of landmark names. 
```{r}
data <- coords.3D[, 2:(dim(coords.3D)[2])]  # removes LM names for geomorph
data <- t(data)
A <- arrayspecs(data, 405, 3)  # convert to 3D array w 405 pts & 3D coords
```

## Extract metadata table from specimen filenames in shape array
The coordinate data is just shape data unless we can extract any information the landmarker put in each specimen's filename. Starting here, we make a metadata table with specimens in the same order as their coordinates for future analyses. 

### Fix naming of replicate filenames (included to measure user error)
Interspersed throughout the data collection process, AEM landmarked 20 specimens twice. Their specimen names included "_ERR", however, not always in the same place in the filename. 

We correct the naming scheme to be machine-readable and in the process create a list of specimen names which were landmarked twice. In script 05, we use this list to analyze user error relative to variation in our sample. 
```{r}
# Detect replicates
names <- dimnames(A)[[3]]
is.rep <- which(str_detect(names, "_ERR"))

# Remove unpredictable or extra characters in specimen names
names <- gsub("_ERR", "", names)
names <- gsub("_f_", "_", names)
names <- gsub("_m_", "_", names)
dimnames(A)[[3]] <- names  # preserve edits for next steps

# Give every specimen name a tag as a replicate (ERR) or non-replicate (non)
for (i in 1:dim(A)[3]){  # 1 to highest number of specimens
        if (i %in% is.rep) {
              dimnames(A)[[3]][i] <- paste(names[i],"ERR", sep = "_")
        } else (dimnames(A)[[3]][i] <- paste(names[i],"non", sep = "_"))
}

# Make list of replicated specimens for later
names <- gsub("_small", "", names)
names <- gsub("_big", "", names)
rep.spec <- unique(names[is.rep])
```

### Run function to scrape filenames for metadata
The `WriteMetadata()` function makes a metadata table in the same order of specimens in the shape array. It takes the 3D array created from Viewbox's coordinate file and a character vector, cols, naming the attributes separated by "_" in specimen filenames. 

In this dataset, the filenames look like: Pse_aus_C12345_small_non for genus, species, catalog number, patch protocol, and replicate status. The corresponding cols vector would be cols <- c(Genus, Species, CatNum, Patch, Rep).
```{r}
WriteMetadata <- function(threeD.array, cols) {
        # Makes metadata table from specimen filenames for shape coordinates.
        #
        # Args:
        #    threeD.array: 3D array (p x k x n), where p is the number of landmarks, k is the dimension (3), and n is the number of specimens. Assumes the 1st column of landmark names has been removed. 
        #    cols: a character vector of column names of length n-1, where n is the number of underscores separating metadata information in the specimen filenames. Assumes filenames contain information in the same order and the appropriate names are given in this order in cols. 
        #
        # Returns: 
        #    A dataframe containing the metadata for each specimen in the same order as specimens in the 3D array of shape data.
        
        # Remove 'ind' that bilat.symmetry() appends to specimen names
        names <- gsub("ind", "", dimnames(threeD.array)[[3]])

        # Convert name vectors into data frame
        categories <- strsplit(names, "_") 
        my.classifiers <- matrix(unlist(categories), ncol = length(cols), byrow = T) 
        colnames(my.classifiers) <- cols
        sp.info <- as.data.frame(my.classifiers)
        
        # Add special columns (requires 'Genus' 'Species' 'CatNum' & 'Rep')
        sp.info$Taxa <- paste(str_sub(sp.info$Genus, 1, 1), str_sub(sp.info$Species, 1, 3), sep = "_")  # turns Mus musculus into M_mus
        sp.info$All <- with(sp.info, interaction(Genus, Species, CatNum, Rep, sep = "_"))  # required to run geomorph's bilat.symmetry()
        
        return(sp.info)
}

# Create metadata table for this dataset
cols = c("Genus", "Species","CatNum","Patch", "Rep")
sp.info <- WriteMetadata(A, cols)
```

## Create shape matrices for each patch protocol
Our methodology tested whether different patch protocols (big and small) impact later shape analyses. To save time, we digitized the patches at the same time so we have two different patch protocols to extract from the same shape coordinate file. 

### Extract landmark point names
```{r}
pt.names <-coords.3D[, 1]  # gets 3D point names from Viewbox
no.XYZ <- str_sub(pt.names, 3, -1)  # removes XYZ appended by Viewbox
u.pt.names<- unique(no.XYZ)  # returns unique point and curve names
```

### Split datasets into small and big patch types
```{r}
# Create data for big patch protocol
big.data <- sp.info$Patch == "big"
big.pts <- which(!str_detect(u.pt.names, "PAT2") & !str_detect(u.pt.names, "SUR2"))  # gets rid of columns left empty for small patch coordinates
B <- A[big.pts, , big.data]
big.sp.info <- sp.info[big.data, ]
big.sp.info$Order <- c(1:nrow(big.sp.info))  # completes big patch dataset
big.pt.names <- u.pt.names[big.pts]  # creates table of unique point names

# Create data for small patch protocol
sm.data <- sp.info$Patch == "small"
sm.pts <- which(!str_detect(u.pt.names, "PAT D"))  # gets rid of columns meant for big patch dataset
S <- A[sm.pts, , sm.data]
sm.sp.info <- sp.info[sm.data, ]
sm.sp.info$Order <- c(1:nrow(sm.sp.info))  # completes small patch dataset
sm.pt.names <- u.pt.names[sm.pts]  # creates table of unique point names
```

## Save intermediate data
Now that we have extracted the 2 patch protocol datasets and the specimen metadata, we are ready for the next analysis step: 02-run-GPA-with-sliding.Rmd. 

Here we save the R objects we will need for later steps so this script does not have to be run again.
```{r}
save(cols, B, big.sp.info, u.pt.names, big.pt.names, file = "../Data/Results/01-big-patch-data.rda")

save(cols, S, sm.sp.info, u.pt.names, sm.pt.names, rep.spec, file = "../Data/Results/01-sm-patch-data.rda")
```