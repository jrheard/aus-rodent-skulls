---
title: "01-data-extraction-for-analyses"
author: "Ariel Marcy"
date: "9/17/2018"
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '../aus-rodent-skulls')
```

# Converting information from Viewbox into shape and metadata
This code extracts two kinds of data from an excel sheet of coordinates from Viewbox, a 3D landmarking software. The first is the shape information from the 3D coordinates. The second is the metadata stored in the filename for each specimen. These datasets need to be treated differently in the upcoming analyses while also remaining comparable by maintaining the same order of specimens.

## Load packages
```{r message = FALSE}
library(dplyr)
library(stringr)
library(stringi)
library(data.table)
library(geomorph)
```

## Load the data 
```{r}
coords3D <- read.csv(here("./Data/Raw/", "3D_coords.csv"), header = T)
```
_Note that the data is loaded in using a relative directory - not a setwd command. This allows others who have cloned this repo of code and data to still use the code out of the box._

## Create metadata table
```{r}
data <- coords3D[, 2:(dim(coords3D)[2])] # removes LM names for geomorph
data <- t(data)
A <- arrayspecs(data, 405, 3) # convert to 3D array w 405 pts & 3 dims
```

## Create function to scrape filenames for metadata
The Metadata function expects a 3D array created from the coordinate file generated by Viewbox with landmark names from the 1st column removed (see code chunk above), threeDarray. It also expects a character vector of attributes which were separated by "_" during the landmarking process, cols. 

In this dataset, the file names look like: Pse_aus_C12345_small, for genus, species, catalog number, and patch protocol. 
```{r}
Metadata <- function(threeDarray, cols) {
        names <- dimnames(threeDarray)[[3]]
        names <- gsub("ind", "", names) # added because geomorph's bilat.symmetry() function appends "ind" to each specimen name
        names <- gsub("_f_", "_", names) 
        names <- gsub("_m_", "_", names)
        names <- gsub("_ERR", "", names)
        
        # Convert name vectors into data frame
        categories <- strsplit(names, "_") 
        my_classifiers <- matrix(unlist(categories), ncol = length(cols), byrow = T) 
        colnames(my_classifiers) <- cols
        sp_info <- as.data.frame(my_classifiers)
        
        # Add special columns (requires cols to be same as this study's:)
        sp_info$Taxa <- paste(str_sub(sp_info$Genus, 1, 1), str_sub(sp_info$Species, 1, 3), sep = "_")
        sp_info$All <- with(sp_info, interaction(Genus, Species, CatNum, sep = "_"))
        return(sp_info)
}

# Create metadata table
cols = c("Genus", "Species","CatNum","Patch")
sp_info <- Metadata(A, cols)
```

## Create shape matrices for each patch protocol
Our methodology tested whether different patch protocols (big and small) impact later shape analyses. To save time, we digitized the patches at the same time so we have two different patch protocols to extract from the same shape coordinate file. 


### Extract landmark point names
```{r}
pt_names <-coords3D[, 1]
foo2 <- str_sub(pt_names, 3, -1)
u_pt_names<- unique(foo2)
```


### Split datasets into small and big patch types
```{r}
# Create data for big patch protocol
big_data <- sp_info$Patch == "big"
big_pts <- which(!str_detect(u_pt_names, "PAT2") & !str_detect(u_pt_names, "SUR2")) # gets rid of columns left empty for small patch coordinates
B <- A[big_pts, , big_data]
big_sp_info <- sp_info[big_data, ]
big_sp_info$Order <- c(1:nrow(big_sp_info)) # completes big patch dataset
big_pt_names <- u_pt_names[big_pts] # creates table of unique point names

# Create data for small patch protocol
sm_data <- sp_info$Patch == "small"
sm_pts <- which(!str_detect(u_pt_names, "PAT D")) # gets rid of columns meant for big patch dataset
S <- A[sm_pts, , sm_data]
sm_sp_info <- sp_info[sm_data, ]
sm_sp_info$Order <- c(1:nrow(sm_sp_info)) # completes small patch dataset
sm_pt_names <- u_pt_names[sm_pts] # creates table of unique point names
```

## Save intermidiate data
Now that we have extracted the 2 patch protocol datasets and the specimen metadata, we are ready for the next analysis step: 02-running-GPA-with-sliding.Rmd. 

Here we save the R objects we will need for later steps so this script does not have to be run again.
```{r}
save(cols, S, sm_sp_info, u_pt_names, sm_pt_names, file = "../Data/Results/01_small_patch_data.rda")

save(cols, B, big_sp_info, u_pt_names, big_pt_names, file = "../Data/Results/01_big_patch_data.rda")
```
