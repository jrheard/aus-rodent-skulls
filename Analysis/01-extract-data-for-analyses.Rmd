---
title: "01-extract-data-for-analyses"
author: "Ariel Marcy"
date: "9/17/2018"
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '../aus-rodent-skulls')
```

# Converting information from Viewbox into shape and metadata
This code extracts two kinds of data from an excel sheet of coordinates from Viewbox, a 3D landmarking software. The first is the shape information from the 3D coordinates. The second is the metadata stored in the filename for each specimen. These datasets need to be treated differently in the upcoming analyses while also remaining comparable by maintaining the same order of specimens.

### Load packages
```{r message = FALSE}
library(dplyr)
library(stringr)
library(stringi)
library(data.table)
library(geomorph)
```

### Load shape data and take out the "burn-in" specimens
_Note that the data is loaded in using a relative directory - not a setwd command. This allows others who have cloned this repo of code and data to still use the code out of the box._

## Remove "burn-in" specimens from dataset to reduce user error
First. to reduce user error, AEM landmarked 20 specimens to familiarize herself with the template and re-landmarked those 20 later on. This is the standard "burn-in" number. Viewbox puts the most recent specimen in the first row of the output .csv file. 
```{r}
coords3D <- read.csv("../Data/Raw/3D_coords.csv", header = T)
coords3D <- coords3D[1:(length(coords3D)-40)] #removes 1st 20 landmarked, 2 protocols per specimen
```

## Create metadata table
The coordinate data is just shape data unless we can extract any information the landmarker put in each specimen's filename. Here, we make a metadata table with specimens in the same order as their coordinates for future analyses. 

First, we convert the coordinates into a 3D array, _geomorph_'s preferred format.
```{r}
data <- coords3D[, 2:(dim(coords3D)[2])] # removes LM names for geomorph
data <- t(data)
A <- arrayspecs(data, 405, 3) # convert to 3D array w 405 pts & 3D coords
```

## Find names of replicates to measure user error
Interspersed throughout the data collection process, AEM landmarked 20 specimens twice. Their filenames included "_ERR". Here, we create a list of specimens which were landmarked twice. Later on we can use it to analyze user error relative to variation in our sample. 
```{r}
names <- dimnames(A)[[3]]
is_rep <- which(str_detect(names, "_ERR"))
rep_names <- names[is_rep]

# Get rid of extra characters in filenames
names <- gsub("_ERR", "", names)
names <- gsub("_f_", "_", names)
names <- gsub("_m_", "_", names)
dimnames(A)[[3]] <- names #preserve edits for next steps

# Make list of replicated specimens
names <- gsub("_small", "", names)
names <- gsub("_big", "", names)
rep_spec <- unique(names[is_rep])
```

### Run function to scrape filenames for metadata
The Metadata function expects a 3D array created from the coordinate file generated by Viewbox with landmark names from the 1st column removed (see code chunk above), threeDarray. It also expects a character vector, cols, of the attributes that were separated by "_" during the landmarking process. 

In this dataset, the filenames look like: Pse_aus_C12345_small, for genus, species, catalog number, and patch protocol. 
```{r}
Metadata <- function(threeDarray, cols) {
        # Remove 'ind' that bilat.symmetry() appends to specimen names
        names <- gsub("ind", "", dimnames(threeDarray)[[3]])

        # Convert name vectors into data frame
        categories <- strsplit(names, "_") 
        my_classifiers <- matrix(unlist(categories), ncol = length(cols), byrow = T) 
        colnames(my_classifiers) <- cols
        sp_info <- as.data.frame(my_classifiers)
        
        # Add special columns (requires 'Genus' 'Species' and 'CatNum cols)
        sp_info$Taxa <- paste(str_sub(sp_info$Genus, 1, 1), str_sub(sp_info$Species, 1, 3), sep = "_") #turns Mus musculus into M_mus
        sp_info$All <- with(sp_info, interaction(Genus, Species, CatNum, sep = "_")) #required to run geomorph's bilat.symmetry()
        
        return(sp_info) #completed metadata table
}

## Create metadata table
cols = c("Genus", "Species","CatNum","Patch")
sp_info <- Metadata(A, cols)
```

## Create shape matrices for each patch protocol
Our methodology tested whether different patch protocols (big and small) impact later shape analyses. To save time, we digitized the patches at the same time so we have two different patch protocols to extract from the same shape coordinate file. 

### Extract landmark point names
```{r}
pt_names <-coords3D[, 1]
foo2 <- str_sub(pt_names, 3, -1)
u_pt_names<- unique(foo2)
```

### Split datasets into small and big patch types
```{r}
# Create data for big patch protocol
big_data <- sp_info$Patch == "big"
big_pts <- which(!str_detect(u_pt_names, "PAT2") & !str_detect(u_pt_names, "SUR2")) # gets rid of columns left empty for small patch coordinates
B <- A[big_pts, , big_data]
big_sp_info <- sp_info[big_data, ]
big_sp_info$Order <- c(1:nrow(big_sp_info)) # completes big patch dataset
big_pt_names <- u_pt_names[big_pts] # creates table of unique point names

# Create data for small patch protocol
sm_data <- sp_info$Patch == "small"
sm_pts <- which(!str_detect(u_pt_names, "PAT D")) # gets rid of columns meant for big patch dataset
S <- A[sm_pts, , sm_data]
sm_sp_info <- sp_info[sm_data, ]
sm_sp_info$Order <- c(1:nrow(sm_sp_info)) # completes small patch dataset
sm_pt_names <- u_pt_names[sm_pts] # creates table of unique point names
```

## Save intermediate data
Now that we have extracted the 2 patch protocol datasets and the specimen metadata, we are ready for the next analysis step: 02-run-GPA-with-sliding.Rmd. 

Here we save the R objects we will need for later steps so this script does not have to be run again.
```{r}
save(cols, B, big_sp_info, u_pt_names, big_pt_names, file = "../Data/Results/01_big_patch_data.rda")

save(cols, S, sm_sp_info, u_pt_names, sm_pt_names, rep_spec, file = "../Data/Results/01_small_patch_data.rda")
```