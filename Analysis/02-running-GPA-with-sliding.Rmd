---
title: "02-running-GPA-with-sliding"
author: "Ariel Marcy"
date: "9/17/2018"
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$get("root.dir")
```

# Running GPA in Geomorph with patches and sliding semi-landmarks
Before we can run the generalized Procrustes alignment (GPA) central to geometric morphometrics, we need to designate which landmarks are fixed, and which ones slide. Furthermore, for the landmarks that slide, we also have to say whether they slide along a curve or if they are patch points sliding along a surface. We begin by classifying the landmarks as fixed points, curve points, and patch points.

```{r}
# Semi-landmark curves
big_cur <- str_detect(big_pt_names, "SUR")
big_cur_num <- which(big_cur == TRUE)

sm_cur <- str_detect(sm_pt_names, "SUR")
sm_cur_num <- which(sm_cur == TRUE)

# Patch points
big_patches <- str_detect(big_pt_names, "PAT")
big_pat_num <- which(big_patches == TRUE)

sm_patches <- str_detect(sm_pt_names, "PAT")
sm_pat_num <- which(sm_patches == TRUE)
```

## Create slider matrices for curve points
Semi-landmark curve points are the most complicated because Geomorph needs to know the landmarks that each point slides between. We wrote a workflow that can do this almost automatically.

```{r message = FALSE}
## Function that creates a slider assuming the entire dataset is one long curve. 
Dummy_Slider <- function(cur_num){
        Before <- (cur_num - 1)
        Slider <- cur_num
        After <- (cur_num + 1)
        matrix <- cbind(Before, Slider, After)
        return(matrix)
}

big_cur_matrix <- Dummy_Slider(big_cur_num)
sm_cur_matrix <- Dummy_Slider(sm_cur_num)
```

Of course, the dataset isn't one long curve, so we need to do a bit of manual work to indicate which landmarks "bound" the min and max points of each curve.

```{r}
# Create table to specify LM names that bound curves
curve_names <- unique(str_sub(sm_pt_names, 1, -5))
curve_names <- curve_names[str_detect(curve_names, "SUR")]
write.csv(curve_names, "curve_names.csv")

LM_key <- read.csv("curve_LM_key.csv", header = T)
```

Here we needed to manually write the names of the landmarks that go before the max curve point and after the curve point's #1. This was done by refering to our template (Fig. TK). 

```{r}
# Import the finished key
LM_key <- read.csv("curve_LM_key.csv", header = T)
```

Finally, we can run a function to find the landmark numbers that correspond with the points that go before and after each curve. 

```{r message = FALSE}
### A function that replaces before and after column numbers with the correct landmark numbers
## requires a list of point names extracted from the coordinate data
## reguires a user-created key with columns:
# "Curve": unique curves (L and R sides should not be duplicated)
# "Before": the landmark that comes before the highest point in the curve, again no R or L side should be indicated
# "After": the landmark that comes after the lowest point in the curve
## A matrix generated by function Dummy_Slider() above
Write_Slider <- function(pt_names, key, matrix){
        
        Give_LMs <- function(i, index, pt_names, key, matrix){
                
                bef_LM <- as.character(LM_key$Before[i])
                if ((sum(str_detect(pt_names, bef_LM)) > 1)) {
                        side <- str_sub(pt_names[min(index)], -3, -3)
                        bef_LM <- paste(bef_LM, side, sep = " ")
                } 
                LM_num <- which(str_detect(pt_names, bef_LM))
                matrix[min(index), 1] <- LM_num
                
                aft_LM <- as.character(key$After[i])
                if (sum(str_detect(pt_names, aft_LM)) > 1) {
                        side <- str_sub(pt_names[min(index)], -3, -3)
                        aft_LM <- paste(aft_LM, side, sep = " ")
                } 
                LM_num <- which(str_detect(pt_names, aft_LM))
                matrix[max(index), 3] <- LM_num
                
                return(matrix)
        }
        
        for (i in 1:length(key$Curve)){
                curve <- as.character(key$Curve[i])
                
                if (sum(str_detect(pt_names, curve) != 0)){
                        index <- which(str_detect(pt_names, curve))
                        test_letter <- str_sub(pt_names[min(index)], -3, -3)
                        if (test_letter != "R" & test_letter != "L"){
                                matrix <- Give_LMs(i, index, pt_names, key, matrix)
                        } else {
                                midpt <- length(index)/2
                                R_index <- index[1:midpt]
                                L_index <- index[(midpt + 1):length(index)]
                                matrix <- Give_LMs(i, R_index, pt_names, key, matrix)
                                matrix <- Give_LMs(i, L_index, pt_names, key, matrix)
                        }
                }

                }
        
        return(matrix)
}

# Create slider matrices for each dataset
big_sli_matrix <- Write_Slider(big_pt_names, LM_key, big_cur_matrix)
sm_sli_matrix <- Write_Slider(sm_pt_names, LM_key, sm_cur_matrix)
```

## Run GPA with sliding curves and patches
Now we have the necessary designations for Geomorph to treat each landmark correctly during GPA. We run it separately for each patch protocol. Geomorph refers to patch points as "surfaces".

```{r message = FALSE}
big_Y <- gpagen(B, Proj = TRUE, ProcD = TRUE, curves = big_sli_matrix, surfaces = big_pat_num)

sm_Y <- gpagen(S, Proj = TRUE, ProcD = TRUE, curves = sm_sli_matrix, surfaces = sm_pat_num)

save(big_Y, sm_Y, file = "02-data.rda")
```