---
title: "04-calculate-user-error"
author: "Ariel Marcy"
date: "9/26/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '../aus-rodent-skulls')
```

### Load packages
```{r message = FALSE}
library(stringr)
library(stringi)
library(data.table)
library(geomorph)
```

### Load data from previous steps
```{r}
load(file = "../Data/Results/01-big-patch-data.rda")
load(file = "../Data/Results/01-sm-patch-data.rda")
load(file = "../Data/Results/02-GPA-data.rda")
load(file = "../Data/Results/03-big-bilat-data.rda")
load(file = "../Data/Results/03-sm-bilat-data.rda")
```

## Separate error measurement datasets from main datasets
Now that the shape data have been processed via GPA and bilateral symmetry, we can separate the data intended to measure user error from the main data for the remaining analyses. 

First, remove the replicates from the main shape data for both small and large patch protocols. Create corresponding metadata tables. These data will be used for the majority of remaining analyses.
```{r}
main <- which(big_bY_info$Rep == "non")
big_shape <- big_bY_ss[, , main]
big_info <- big_bY_info[main, ]

sm_shape <- sm_bY_ss[, , main] # main for small patch protocol is same as above, test with all.equal()
sm_info <- sm_bY_info[main, ]
```

Second, create an error measurement dataset for both protocols that includes replicates and the specimens they duplicated (i.e. each CatNum should have two entries, one labeled "ERR", and one labled "non"). These data will be used to calculate user error. 
```{r}
## Find index for both versions of specimens with replicates using rep_spec list make in script 01.
rep_CatNums <- as.character(str_sub(rep_spec, 9, -1)) # isolate CatNum
error_data <- which(sm_bY_info$CatNum %in% rep_CatNums) # same for small and big patch protocols, can test with all.equal()

## Subset shape and metadata tables for each protcol
big_err_shape <- big_bY_ss[, , error_data]
big_err_info <- big_bY_info[error_data, ]

sm_err_shape <- sm_bY_ss[, , error_data]
sm_err_info <- sm_bY_info[error_data, ]
```

## Calculate user error aka Repeatability
Here, we calculate repeatability from formulas 1-3 in Fruciano 2016. The function below was written for Marcy et al 2018. It expects:
* coords = a 3D array of shape coordinates
* ind = a list of identifiers used to find replicates (in this case, CatNum)
* nRep = number of repetitions taken for each individual (in this case, 2)

The function also gives options for displaying results. The default is printing the ANOVA table to the console. If export is TRUE, then the user can give a filename for the resulting .csv saved to the working directory.
```{r}
## Define repeatability function
Rep_Ability <- function(coords, ind, nRep, print = TRUE, export = FALSE, filename = NULL) {
        r.gdf <- geomorph.data.frame(coords = coords, ind = factor(ind))
        rep.er <- procD.lm(coords ~ ind, data = r.gdf, iter = 999)
        ## Among-individuals variance component:
        S_sq_A <- ((rep.er$aov.table$MS[1] - rep.er$aov.table$MS[2]) / nRep) 
        ## Within-individual variance component:
        S_sq_W <- rep.er$aov.table$MS[2] 
        ## Repeatability (sensu Geometric Morphometrics field)
        R <- S_sq_A / (S_sq_W + S_sq_A) # analogue of the intraclass correlation coeffiecent
        
        table <- rep.er$aov.table
        table$Repeatability <- R
        
        ## Display options
        if (print) {
                print(rep.er$aov.table)
                cat("\n","Repeatability =", R)
        }
        if (export) {
                write.csv(table, file = paste(filename, ".csv", sep = ""))
        }
}
```

Calculate repeatability for both patch protocols
```{r}
Rep_Ability(big_err_shape, big_err_info$CatNum, nRep = 2)
Rep_Ability(sm_err_shape, sm_err_info$CatNum, nRep = 2)
```

### Save intermediate data
```{r}
save(big_shape, big_info, sm_shape, sm_info, file = "../Data/Results/04-data-for-analyses.rda")
```
