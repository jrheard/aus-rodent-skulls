---
title: "04-calculate-user-error"
author: "Ariel Marcy"
date: "9/26/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '../aus-rodent-skulls')
```
# Calculate user error
Geometric morphometric studies usually require a lot of user-generated data and it's important to assess how much user error is created during the landmarking process. Here, we compare the shape variation between 20 individuals, from a variety of different species, landmarked twice.

### Load packages
```{r message = FALSE}
library(stringr)
library(stringi)
library(data.table)
library(geomorph)
```

### Load data from previous steps
```{r}
load(file = "../Data/Results/01-big-patch-data.rda")
load(file = "../Data/Results/01-sm-patch-data.rda")
load(file = "../Data/Results/02-GPA-data.rda")
load(file = "../Data/Results/03-big-bilat-data.rda")
load(file = "../Data/Results/03-sm-bilat-data.rda")
```

## Separate error measurement datasets from main datasets
Now that the shape data have been processed via GPA and bilateral symmetry, we can separate the data intended to measure user error from the main data for the remaining analyses. 

First, remove the replicates from the main shape data for both small and large patch protocols. Create corresponding metadata tables. These data will be used for the majority of remaining analyses.
```{r}
main <- which(big.bY.info$Rep == "non")
big.shape <- big.bY.ss[, , main]
big.info <- big.bY.info[main, ]

sm.shape <- sm.bY.ss[, , main]  # main for small patch protocol is same as for the big patch protocol, tested with all.equal()
sm.info <- sm.bY.info[main, ]
```

Second, create an error measurement dataset for both protocols that includes replicates and the specimens they duplicated (i.e. each CatNum should have two entries, one labeled "ERR", and one labled "non"). These data will be used to calculate user error. 
```{r}
# Find index for both versions of specimens with replicates using rep.spec list make in script 01.
rep.CatNums <- as.character(str_sub(rep.spec, 9, -1))  # isolate CatNum
error.data <- which(sm.bY.info$CatNum %in% rep.CatNums)  # same for small and big patch protocols, tested with all.equal()

# Subset shape and metadata tables for each protcol
big.err.shape <- big.bY.ss[, , error.data]
big.err.info <- big.bY.info[error.data, ]

sm.err.shape <- sm.bY.ss[, , error.data]
sm.err.info <- sm.bY.info[error.data, ]
```

## Calculate user error aka Repeatability
Here, we calculate repeatability from formulas 1-3 in Fruciano 2016. The function below was written for Marcy et al 2018. 
```{r}
RepAbility <- function(coords, ids, nRep, print = TRUE, export = FALSE, filename = NULL) {
        # Calculates repeatability (R) for GMM studies.
        #
        # Args:
        #    coords: a 3D array (p x k X n) of shape coordinates.
        #    IDs: a list of identifiers used to find replicates, e.g. CatNum.
        #    nRep: number of repetitions taken for each individual
        #    print: if TRUE, prints ANOVA and R to the console.
        #    export: if TRUE, exports ANOVA and R to .csv.
        #    filename: the filename used to save the .csv file.
        #
        # Returns:
        #    A table with the ANOVA and the value of R, repeatability.
        
        # Calculations from formulas 1-3 in Fruciano 2016
        r.gdf <- geomorph.data.frame(coords = coords, ind = factor(ids))
        rep.er <- procD.lm(coords ~ ind, data = r.gdf, iter = 999)
        S.sq.A <- ((rep.er$aov.table$MS[1] - rep.er$aov.table$MS[2]) / nRep)  # among-individuals variance component: 
        S.sq.W <- rep.er$aov.table$MS[2]  # within-individual variance
        R <- S.sq.A / (S.sq.W + S.sq.A)  # analogue of the intraclass correlation coeffiecent
        
        table <- rep.er$aov.table
        table$Repeatability <- R
        
        if (print) {
                print(rep.er$aov.table)
                cat("\n","Repeatability =", R)
        }
        if (export) {
                write.csv(table, file = paste(filename, ".csv", sep = ""))
        } else {
                return (table)
        }
}
```

Calculate repeatability for both patch protocols
```{r}
RepAbility(big.err.shape, big.err.info$CatNum, nRep = 2)
RepAbility(sm.err.shape, sm.err.info$CatNum, nRep = 2)
```

### Save intermediate data
```{r}
save(big.shape, big.info, sm.shape, sm.info, file = "../Data/Results/04-data-for-analyses.rda")
```