---
title: "04-calculate-user-error"
author: "Ariel Marcy"
date: "9/26/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '../aus-rodent-skulls')
```
# Calculate user error
Geometric morphometric studies usually require a lot of user-generated data and it's important to assess how much user error is created during the landmarking process. Here, we compare the shape variation between 20 individuals, from a variety of different species, landmarked twice.

### Load packages and functions
```{r message = FALSE}
library(stringr)
library(stringi)
library(data.table)
library(geomorph)
source("../Functions/utilities.R")  # loads custom functions called by these scripts but defined in the Functions/utilities.R file for conciseness.
```

### Load data from previous steps
```{r}
load(file = "../Data/Results/01-big-patch-data.rda")
load(file = "../Data/Results/01-sm-patch-data.rda")
load(file = "../Data/Results/02-GPA-data.rda")
load(file = "../Data/Results/03-big-bilat-data.rda")
load(file = "../Data/Results/03-sm-bilat-data.rda")
```

## Separate error measurement datasets from main datasets
Now that the shape data have been processed via GPA and bilateral symmetry, we can separate the data intended to measure user error from the main data for the remaining analyses. 

First, remove the replicates from the main shape data for both small and large patch protocols. Create corresponding metadata tables. These data will be used for the majority of remaining analyses.
```{r}
main <- which(big.bY.info$Rep == "non")
big.shape <- big.bY.ss[, , main]
big.info <- big.bY.info[main, ]

sm.shape <- sm.bY.ss[, , main]  # main is the same for big and small patch protocols, tested with all.equal()
sm.info <- sm.bY.info[main, ]
```

Second, create an error measurement dataset for both protocols that includes replicates and the specimens they duplicated (i.e. each CatNum should have two entries, one labeled "ERR", and one labled "non"). These data will be used to calculate user error. 
```{r}
# Find index for both versions of specimens with replicates using rep.spec list make in script 01.
rep.CatNums <- as.character(str_sub(rep.spec, 9, -1))  # isolate CatNum
error.data <- which(sm.bY.info$CatNum %in% rep.CatNums)  # error.data is the same for small and big patch protocols, tested with all.equal()

# Subset shape and metadata tables for each protcol
big.err.shape <- big.bY.ss[, , error.data]
big.err.info <- big.bY.info[error.data, ]

sm.err.shape <- sm.bY.ss[, , error.data]
sm.err.info <- sm.bY.info[error.data, ]
```

## Calculate user error aka Repeatability
Here, we calculate repeatability for each patch protocol from formulas 1-3 in Fruciano 2016. The function `RepAbility()` was modified from Marcy et al 2018. 
```{r}
RepAbility(big.err.shape, big.err.info$CatNum, n.Rep = 2)
RepAbility(sm.err.shape, sm.err.info$CatNum, n.Rep = 2)
```

## Calculate repeatability without patch points
Patch points could be artificially inflating our repeatability numbers. To test this, we calculated repeatability for the small and big patch datasets with patch points removed. 

Note that removing patch points will remove 16 more points from the big patch protocol than the small patch protocol. 
```{r}
# Subset the shape datasets for only fixed LMs and curve semi-LMs
big.patchless.shape <- big.err.shape[-big.pat.num, , ] 
sm.patchless.shape <- sm.err.shape[-sm.pat.num, , ]

# Run repeatability again
RepAbility(big.patchless.shape, big.err.info$CatNum, n.Rep = 2)
RepAbility(sm.patchless.shape, sm.err.info$CatNum, n.Rep = 2)
```
Taking out patch points does decrease the repeatability by about 1% for each protocol:
Big Patch is 92.6% with patches, 91.6% without patches (140 points removed)
Small Patch: 92.5% with patches, 91.7% without patches (124 points removed) 

### Save intermediate data
```{r}
save(big.shape, big.info, sm.shape, sm.info, file = "../Data/Results/04-data-for-analyses.rda")
```