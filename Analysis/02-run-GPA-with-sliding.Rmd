---
title: "02-run-GPA-with-sliding"
author: "Ariel Marcy"
date: "9/17/2018"
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '../aus-rodent-skulls')
```

# Running GPA with sliding requires categorized landmarks and defined curves 
Before we can run the generalized Procrustes alignment (GPA) central to geometric morphometrics, we need to designate which landmarks are fixed, and which ones slide. The landmarking protocol of our study used 3 different kinds of landmarks: 
1) Fixed landmarks which do not slide in any direction.
2) Curve semi-landmarks which slide in 1 dimension along a curve.
3) Patch semi-landmarks which slide in 2 dimensions across a surface. 

For _geomorph_ to handle semi-landmarks correctly, it needs to know:
1) Is it a curve or a patch semi-landmark?
2) If it is a curve, which other landmarks define the curve?

This code sets up a mostly automated workflow to categorize landmarks and define curves. It will need some information from the user about which fixed landmarks bound which curves in a specific protocol.  

### Load packages and functions
```{r message = FALSE}
library(stringr)
library(stringi)
library(data.table)
library(geomorph)
source("../Functions/utilities.R")  # loads custom functions called by these scripts but defined in the Functions/utilities.R file for conciseness.
```

### Load data from previous step
Use .rda files with objects from the previous script, 01-extract-data-for-analyses.Rmd.
```{r}
load(file = "../Data/Results/01-big-patch-data.rda")
load(file = "../Data/Results/01-sm-patch-data.rda")
```

**This workflow expects:**
1. The user included "SUR" in all curve semi-landmark names, "PAT" in all patch semi-landmark names.

2. For bilateral names, "R" and "L" designate sides after the landmark's name.

3. For curve points, "1", "2", "3", etc ascend in one direction, with bilateral curves sharing the same direction (e.g. numbers go up Anterior -> Posterior).

_For example, "SUR occipital suture R 2" is anterior to "SUR occipital suture R 3"; same numbering on the Left side_

4. For patches, bilateral points should have the same point number.

_For example, "PAT auditory bulla R 3" and "PAT auditory bulla L 3" are in mirror image locations on their respective patches_

## Categorize landmarks by sliding type
First, we identify the point names and their associated index numbers using the naming conventions explained above. Importantly, index numbers will correspond to the landmarks in the shape files, S and B. 
```{r}
# Semi-landmark curves
big.cur <- str_detect(big.pt.names, "SUR")
big.cur.num <- which(big.cur == TRUE)

sm.cur <- str_detect(sm.pt.names, "SUR")
sm.cur.num <- which(sm.cur == TRUE)

# Patch points
big.patches <- str_detect(big.pt.names, "PAT")
big.pat.num <- which(big.patches == TRUE)

sm.patches <- str_detect(sm.pt.names, "PAT")
sm.pat.num <- which(sm.patches == TRUE)
```

## Define curves for curve semilandmarks
Semi-landmark curve points are the most complicated because _geomorph_ needs to know the landmarks that each point slides between. Here's a 3-step workflow that can do most of this automatically.

### 1) Make dummy slider matrix
_geomorph_ needs a "slider matrix" to slide curve semi-landmarks along their appropriate curves. The matrix has three columns: Before, Slider, and After. The "Slider" is the semi-landmark it's currently sliding. Before and After are the landmarks (or semi-landmarks) that it slides between. 

`StartSlider()` makes a dummy slider matrix in the format _geomorph_ expects. It simply generates the Before and After landmark numbers by subtracting or adding from the current slider point's index number. This scheme works for most of the slider matrix because we named curves in a way so that their names are next to each other, just like they are next to each other on the specimen.
```{r}
# Start sliders for both patch protocols
big.cur.matrix <- StartSlider(big.cur.num)
sm.cur.matrix <- StartSlider(sm.cur.num)
```

### 2) Create table of landmark names bounding curves
The `StartSlider()` function got us most of the way with the sliding matrix, but we need to define the Before and After landmarks that bound each curve. The landmarks that bound each curve will not have a predictable pattern since they are named "LM" and end up elsewhere in the alphabetical list of landmark names and/or one LM bounds several semi-landmark curves.

So, we need to do a bit of manual work to tell R about our specific landmarking template.

But, we can help ourselves by generating a list of curve names found on just one side of the specimen.
```{r}
# Create table to specify landmark names that bound curves
curve.names <- unique(str_sub(sm.pt.names, 1, -5))  # removes number and R or L designations
curve.names <- curve.names[str_detect(curve.names, "SUR")]  # narrows down to only curve names
curve.key <- data.frame(Before = 0, Curve = curve.names, After = 0)
write.csv(curve.key, "../Data/Processed/curve_key.csv")
```

For the 28 unique curves in the curve_key.csv, we manually replaced the zeros with the names for:
* Before = the landmark near the curve point with the maximum number.
* After = the landmark near the curve point's #1. 

We did not include R or L designations. For our rationale, refer to our template (Fig. TK). Once ready, we re-named this table, "curve_LM_key.csv"
```{r}
# Import the finished key
LM.key <- read.csv("../Data/Processed/curve_LM_key.csv", header = T)
```

### 3) Complete slider matrix with correct landmark numbers
Finally, we wrote two functions that connect the landmark names in the Before and After columns with their row number in the shape data and update the slider with the correct numbers. 

The first function, `FindLMnumbers()`, puts the correct landmark numbers in the slider matrix Before and After columns for one curve. It is run within the second function, `FinishSlider()`.

The second function, `FinishSlider()` handles all the information in the LM_key to direct the function, `FindLMnumbers()` above. `FinishSlider()` returns a completed slider matrix.

At last, creating the slider matrices for two different patch protocols only takes 2 lines of code:
```{r}
big.sli.matrix <- FinishSlider(big.pt.names, LM.key, big.cur.matrix)
sm.sli.matrix <- FinishSlider(sm.pt.names, LM.key, sm.cur.matrix)
```

## Run GPA with sliding curves and patches
Now we have the necessary LM categories and curve definitions for _geomorph_ to treat each landmark correctly during GPA. We run it separately for each patch protocol. _geomorph_ refers to patch points as "surfaces".
```{r}
big.Y <- gpagen(B, Proj = TRUE, ProcD = TRUE, curves = big.sli.matrix, surfaces = big.pat.num)

sm.Y <- gpagen(S, Proj = TRUE, ProcD = TRUE, curves = sm.sli.matrix, surfaces = sm.pat.num)

## Save intermediate data
save(big.Y, sm.Y, file = "../Data/Results/02-GPA-data.rda")
```