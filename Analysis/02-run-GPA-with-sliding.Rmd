---
title: "02-run-GPA-with-sliding"
author: "Ariel Marcy"
date: "9/17/2018"
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '../aus-rodent-skulls')
```

# Running GPA with sliding requires categorized landmarks and defined curves 
Before we can run the generalized Procrustes alignment (GPA) central to geometric morphometrics, we need to designate which landmarks are fixed, and which ones slide. The landmarking protocol of our study used 3 different kinds of landmarks: 
1) Fixed landmarks which do not slide in any direction.
2) Curve semi-landmarks which slide in 1 dimension along a curve.
3) Patch semi-landmarks which slide in 2 dimensions across a surface. 

For _geomorph_ to handle semi-landmarks correctly, it needs to know:
1) Is it a curve or a patch semi-landmark?
2) If it is a curve, which other landmarks define the curve?

This code sets up a mostly automated workflow to categorize landmarks and define curves. It will need some information from the user about which fixed landmarks bound which curves in a specific protocol.  

### Load packages
```{r message = FALSE}
library(stringr)
library(stringi)
library(data.table)
library(geomorph)
```

### Load data from previous step
Use .rda files with objects from the previous script, 01-extract-data-for-analyses.Rmd.
```{r}
load(file = "../Data/Results/01-big-patch-data.rda")
load(file = "../Data/Results/01-sm-patch-data.rda")
```

**This workflow expects:**
1. The user included "SUR" in all curve semi-landmark names, "PAT" in all patch semi-landmark names.

2. For bilateral names, "R" and "L" designate sides after the landmark's name.

3. For curve points, "1", "2", "3", etc ascend in one direction, with bilateral curves sharing the same direction (e.g. numbers go up Anterior -> Posterior).

_For example, "SUR occipital suture R 2" is anterior to "SUR occipital suture R 3"; same numbering on the Left side_

4. For patches, bilateral points should have the same point number.

_For example, "PAT auditory bulla R 3" and "PAT auditory bulla L 3" are in mirror image locations on their respective patches_

## Categorize landmarks by sliding type
First, we identify the point names and their associated index numbers using the naming conventions explained above. Importantly, index numbers will correspond to the landmarks in the shape files, S and B. 
```{r}
# Semi-landmark curves
big.cur <- str_detect(big.pt.names, "SUR")
big.cur.num <- which(big.cur == TRUE)

sm.cur <- str_detect(sm.pt.names, "SUR")
sm.cur.num <- which(sm.cur == TRUE)

# Patch points
big.patches <- str_detect(big.pt.names, "PAT")
big.pat.num <- which(big.patches == TRUE)

sm.patches <- str_detect(sm.pt.names, "PAT")
sm.pat.num <- which(sm.patches == TRUE)
```

## Define curves for curve semilandmarks
Semi-landmark curve points are the most complicated because _geomorph_ needs to know the landmarks that each point slides between. Here's a 3-step workflow that can do most of this automatically.

### 1) Make dummy slider matrix
_geomorph_ needs a "slider matrix" to slide curve semi-landmarks along their appropriate curves. The matrix has three columns: Before, Slider, and After. The "Slider" is the semi-landmark it's currently sliding. Before and After are the landmarks (or semi-landmarks) that it slides between. 

`StartSlider()` makes a dummy slider matrix in the format _geomorph_ expects. It simply generates the Before and After landmark numbers by subtracting or adding from the current slider point's index number. This scheme works for most of the slider matrix because we named curves in a way so that their names are next to each other, just like they are next to each other on the specimen.
```{r}
StartSlider <- function(cur.num){
        # Creates a _geomorph_ slider matrix with correct After and Before landmark numbers for semi-landmarks in the middle of their curve. 
        #
        # Args:
        #    cur.num: an integer vector of landmarks categorized as curve semi-landmarks
        #
        # Returns:
        #   A matrix ready for geomorph's gpagen() curves = argument. It will be missing appropriate Before and After numbers for fixed landmarks bounding every curve.
        Before <- (cur.num - 1)
        Slider <- cur.num
        After <- (cur.num + 1)
        matrix <- cbind(Before, Slider, After)
        return(matrix)
}

# Start sliders for both patch protocols
big.cur.matrix <- StartSlider(big.cur.num)
sm.cur.matrix <- StartSlider(sm.cur.num)
```

### 2) Create table of landmark names bounding curves
The `StartSlider()` function got us most of the way with the sliding matrix, but we need to define the Before and After landmarks that bound each curve. The landmarks that bound each curve will not have a predictable pattern since they are named "LM" and end up elsewhere in the alphabetical list of landmark names and/or one LM bounds several semi-landmark curves.

So, we need to do a bit of manual work to tell R about our specific landmarking template.

But, we can help ourselves by generating a list of curve names found on just one side of the specimen.
```{r}
# Create table to specify landmark names that bound curves
curve.names <- unique(str_sub(sm.pt.names, 1, -5))  # removes number and R or L designations
curve.names <- curve.names[str_detect(curve.names, "SUR")]  # narrows down to only curve names
curve.key <- data.frame(Before = 0, Curve = curve.names, After = 0)
write.csv(curve.key, "../Data/Processed/curve_key.csv")
```

For the 28 unique curves in the curve_key.csv, we manually replaced the zeros with the names for:
* Before = the landmark near the curve point with the maximum number.
* After = the landmark near the curve point's #1. 

We did not include R or L designations. For our rationale, refer to our template (Fig. TK). Once ready, we re-named this table, "curve_LM_key.csv"
```{r}
# Import the finished key
LM.key <- read.csv("../Data/Processed/curve_LM_key.csv", header = T)
```

### 3) Complete slider matrix with correct landmark numbers
Finally, we wrote two functions that connect the landmark names in the Before and After columns with their row number in the shape data and update the slider with the correct numbers. 

The first function, 'Give_LMs()', puts the correct landmark numbers in the slider matrix Before and After columns for one curve. It is run within the second function, `FinishSlider()`.
```{r}
FindLMnumbers <- function(i, index, pt.names, key, matrix){
        # Finds row numbers in shape data for 2 named LMs bounding a curve. 
        #
        # Args:
        #    i: an integer corresponding to the row number of a curve name in the key argument fed to `FinishSlider()`
        #    index: an integer vector of curve points row numbers
        #    pt.names: a list of point names in the landmarking protocol
        #    matrix: a slider matrix with 3 columns to be edited, e.g. one created by the function `StartSlider()`
        #
        # Returns:
        #    A slider matrix with correct landmark numbers for LMs bounding one curve, given by row number, i. 
              
        bef.LM <- as.character(key$Before[i])  # Before landmark name
        
        # Checks if this landmark is bilateral and if so, appends the appropriate "R" or "L" so the correct landmark number is retrieved later
        if ((sum(str_detect(pt.names, bef.LM)) > 1)) {
                side <- str_sub(pt.names[min(index)], -3, -3)
                bef.LM <- paste(bef.LM, side)
        } 
        # Finds & inserts landmark number in slider matrix Before column
        LM.num <- which(str_detect(pt.names, bef.LM))
        matrix[min(index), 1] <- LM.num
                
        aft.LM <- as.character(key$After[i])  # After landmark name
        
        # Checks if this landmark is bilateral
        if (sum(str_detect(pt.names, aft.LM)) > 1) {
                side <- str_sub(pt.names[min(index)], -3, -3)
                aft.LM <- paste(aft.LM, side)
        } 
        # Finds & inserts landmark number in After column
        LM.num <- which(str_detect(pt.names, aft.LM))
        matrix[max(index), 3] <- LM.num
                
        return(matrix)
}
```

The second function, `FinishSlider()` handles all the information in the LM_key to direct the function, `FindLMnumbers()` above.

`FinishSlider()` returns a completed slider matrix.
```{r}
FinishSlider <- function(pt.names, key, matrix){
        # Corrects numbers for bounding LMs for all curves in a sliding matrix intended for gpagen()'s argument curves. 
        #
        # Args:
        #    pt.names: a character list of point names
        #    key: the user-generated matrix with column "Curve" listing unique curve names, "Before" and "After" listing bounding landmark names
        #    matrix: a 3-column matrix initiated by `StartSlider()`.
        #
        # Returns
        #    A completed slider matrix ready for geomorph's gpagen()
        
        # Cycles through unique curve names in the template
        for (i in 1:length(key$Curve)){  # i passed to Give_LMs()
                curve <- as.character(key$Curve[i]) 
                
                # Checks to make sure more than 1 sliding pt in curve
                # If so, gets the index numbers included in curve
                # Also extracts letter which might indicate L or R
                if (sum(str_detect(pt.names, curve) != 0)){
                        index <- which(str_detect(pt.names, curve))
                        test.LR <- str_sub(pt.names[min(index)], -3, -3)
                        
                        # Tests for and handles center-line curves
                        if (test.LR != "L" & test.LR != "R"){
                                matrix <- FindLMnumbers(i, index, pt.names, key, matrix)
                        } else { # Handles bilateral curves, expecting the coordinates in reverse alphabetical order that lists the R side points immediately before the L side points
                                midpt <- length(index)/2
                                R.index <- index[1:midpt]
                                L.index <- index[(midpt + 1):(midpt*2)]
                                matrix <- FindLMnumbers(i, R.index, pt.names, key, matrix)
                                matrix <- FindLMnumbers(i, L.index, pt.names, key, matrix)
                        }
                }
        }
        return(matrix)
}
```

At last, creating the slider matrices for two different patch protocols only takes 2 lines of code:
```{r}
big.sli.matrix <- FinishSlider(big.pt.names, LM.key, big.cur.matrix)
sm.sli.matrix <- FinishSlider(sm.pt.names, LM.key, sm.cur.matrix)
```

## Run GPA with sliding curves and patches
Now we have the necessary LM categories and curve definitions for _geomorph_ to treat each landmark correctly during GPA. We run it separately for each patch protocol. _geomorph_ refers to patch points as "surfaces".
```{r}
big.Y <- gpagen(B, Proj = TRUE, ProcD = TRUE, curves = big.sli.matrix, surfaces = big.pat.num)

sm.Y <- gpagen(S, Proj = TRUE, ProcD = TRUE, curves = sm.sli.matrix, surfaces = sm.pat.num)

## Save intermediate data
save(big.Y, sm.Y, file = "../Data/Results/02-GPA-data.rda")
```